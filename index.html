<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>肉鸽扑克牌 — Roguelike Poker (Demo)</title>
<style>
  :root{
    --bg:#071b16; --panel:#0a3a2f; --accent:#ffd166; --muted:#9fbfb0;
    --card-bg:#fff; --card-color:#111;
  }
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#05120e,#07261e);color:#eaf6ee;min-height:100vh;display:flex;justify-content:center;padding:20px}
  .wrap{width:100%;max-width:1100px}
  header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
  h1{margin:0;font-size:20px}
  .topbar{margin-left:auto;display:flex;gap:10px;align-items:center}
  .game{display:grid;grid-template-columns: 560px 1fr; gap:12px}
  .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:12px;padding:12px}
  .board{background:var(--panel);border-radius:12px;padding:12px;min-height:480px}
  .stats{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;margin-bottom:10px}
  .row{display:flex;gap:8px;align-items:center}
  .card{width:66px;height:96px;border-radius:8px;background:var(--card-bg);color:var(--card-color);display:flex;align-items:center;justify-content:center;font-weight:800;box-shadow:0 6px 18px rgba(0,0,0,0.4)}
  .card.back{background:linear-gradient(180deg,#0b7,#058);color:transparent}
  .small{font-size:13px;color:var(--muted)}
  .btn{padding:8px 12px;border-radius:8px;border:none;background:var(--accent);color:#062a20;font-weight:800;cursor:pointer}
  .btn.ghost{background:transparent;border:1px solid rgba(255,209,102,0.12);color:var(--accent)}
  .log{height:140px;overflow:auto;background:rgba(0,0,0,0.18);padding:8px;border-radius:8px;margin-top:8px}
  .map{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  .room{padding:8px 10px;border-radius:8px;background:rgba(0,0,0,0.12);min-width:110px;text-align:center}
  .actions{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  input[type=number]{width:96px;padding:6px;border-radius:6px;border:none}
  .center{display:flex;justify-content:center}
  footer{margin-top:12px;color:var(--muted)}
  @media(max-width:980px){.game{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>肉鸽扑克牌 — Roguelike Poker（Demo）</h1>
    <div class="topbar">
      <div class="small">层数 <span id="depth">1</span></div>
      <div class="small">金币 <span id="gold">0</span></div>
      <div class="small">经验 <span id="xp">0</span></div>
      <button id="restart" class="btn">重置游玩</button>
    </div>
  </header>

  <div class="game">
    <!-- 左：主战斗/桌面 -->
    <div class="panel board" id="board">
      <div class="stats">
        <div class="row"><div><strong id="stageLabel">准备</strong></div><div style="margin-left:auto" class="small">当前房间: <span id="roomLabel">—</span></div></div>
        <div class="row" style="margin-top:8px">
          <div>生命: <strong id="hp">30</strong>/<span id="maxHp">30</span></div>
          <div style="margin-left:12px">伤害倍率: <strong id="dmgMult">1.0</strong></div>
          <div style="margin-left:auto" class="small">下注: <input id="wager" type="number" value="20"> <span class="small">（赌注放大伤害/奖励）</span></div>
        </div>
      </div>

      <div style="display:flex;gap:12px;align-items:flex-start">
        <div style="flex:1">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div><strong>对手</strong> <span id="enemyName" class="small"></span></div>
            <div class="small">生命: <strong id="enemyHp">—</strong></div>
          </div>
          <div style="margin-top:8px;display:flex;gap:10px;align-items:center">
            <div id="enemyCards" style="display:flex;gap:8px"></div>
            <div style="margin-left:auto" class="small">伤害加成: <span id="enemyMul">x1</span></div>
          </div>

          <div style="margin-top:20px"><strong>公共牌</strong>
            <div id="community" style="display:flex;gap:8px;margin-top:8px"></div>
          </div>

          <div style="margin-top:18px">
            <strong>你</strong>
            <div class="small">生命: <span id="playerHp">—</span></div>
            <div style="margin-top:8px" id="playerCards" class="row"></div>
          </div>
        </div>

        <div style="width:210px">
          <div><strong>房间列表（本层）</strong></div>
          <div class="map" id="rooms"></div>

          <div style="margin-top:12px"><strong>商店 / 升级</strong>
            <div id="shop" class="small" style="margin-top:6px">在商店内可购买强化。</div>
          </div>

          <div style="margin-top:8px">
            <strong>日志</strong>
            <div class="log" id="log"></div>
          </div>
        </div>
      </div>

      <div class="actions">
        <button id="enterBtn" class="btn">进入房间</button>
        <button id="dealBtn" class="btn">发牌 / 决斗</button>
        <button id="foldBtn" class="btn ghost">弃牌</button>
        <button id="nextBtn" class="btn ghost">前往下一房间</button>
      </div>
    </div>

    <!-- 右：信息 / 升级 -->
    <div class="panel">
      <div>
        <div><strong>玩家信息</strong></div>
        <div class="small" style="margin-top:8px">等级: <span id="lvl">1</span> / 金币: <span id="gold2">0</span></div>
        <div class="small" style="margin-top:6px">可用升级点: <span id="skillPoints">0</span></div>
        <div style="margin-top:10px">
          <strong>主动升级（每次成功击败房间获得金币/经验）</strong>
          <div style="display:flex;gap:8px;margin-top:6px;flex-wrap:wrap">
            <button class="btn ghost" id="buyHp">+MaxHP (100g)</button>
            <button class="btn ghost" id="buyDmg">+Damage Mult (120g)</button>
            <button class="btn ghost" id="buyWild">购买 野牌 (200g)</button>
          </div>
        </div>

        <div style="margin-top:12px">
          <strong>提示</strong>
          <div class="small">玩法：进入房间可为战斗下注（wager），发牌后两方比牌，牌力大的造成伤害。胜利获得金币/经验并可在商店花费金币升级。每过若干房间可进下一层（更强敌人）。</div>
        </div>
      </div>
    </div>
  </div>

  <footer class="small center">保存 / 多人/边池 需要后端；若想做成完整商用版本我可以继续把后端 + 更复杂规则补完。</footer>
</div>

<script>
/* ---- 基础牌与评估函数（7张牌选最佳5张） ---- */
const RANKS = ['2','3','4','5','6','7','8','9','T','J','Q','K','A'];
const SUITS = ['s','h','d','c'];
function createDeck(){ const d=[]; for(const r of RANKS) for(const s of SUITS) d.push(r+s); return shuffle(d); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function cardText(code){ if(!code) return ''; const map={s:'♠',h:'♥',d:'♦',c:'♣'}; return code[0]+map[code[1]]; }

/* Evaluate 5-card as in previous: return [rankCategory, tiebreakers...] */
function evaluate5(cards){
  const ranks = cards.map(c=>c[0]);
  const suits = cards.map(c=>c[1]);
  const counts = {};
  for(const r of ranks) counts[r]=(counts[r]||0)+1;
  const byCount = {};
  for(const [r,c] of Object.entries(counts)){ byCount[c]=byCount[c]||[]; byCount[c].push(RANKS.indexOf(r)); }
  for(const k in byCount) byCount[k].sort((a,b)=>b-a);
  const suitCounts = {};
  for(const s of suits) suitCounts[s]=(suitCounts[s]||0)+1;
  const isFlush = Object.values(suitCounts).some(v=>v>=5);
  const uniqRanks = Array.from(new Set(ranks.map(r=>RANKS.indexOf(r)))).sort((a,b)=>a-b);
  let isStraight=false, topStraight=-1;
  for(let i=0;i<uniqRanks.length;i++){
    let seq=1, last=uniqRanks[i];
    for(let j=i+1;j<uniqRanks.length;j++){
      if(uniqRanks[j]===last+1){seq++; last=uniqRanks[j];} else break;
    }
    if(seq>=5){ isStraight=true; topStraight=last; break; }
  }
  if(!isStraight){
    const wheel=['A','2','3','4','5']; if(wheel.every(r=>ranks.includes(r))){ isStraight=true; topStraight=RANKS.indexOf('5'); }
  }
  let isSF=false, topSF=-1;
  for(const s of SUITS){
    const rc = cards.filter(c=>c[1]===s).map(c=>c[0]);
    const idxs = Array.from(new Set(rc.map(r=>RANKS.indexOf(r)))).sort((a,b)=>a-b);
    for(let i=0;i<idxs.length;i++){
      let seq=1, last=idxs[i];
      for(let j=i+1;j<idxs.length;j++){
        if(idxs[j]===last+1){seq++; last=idxs[j]} else break;
      }
      if(seq>=5){ isSF=true; topSF=last; break; }
    }
    if(!isSF){ const wheel=['A','2','3','4','5']; if(wheel.every(r=>rc.includes(r))){ isSF=true; topSF=RANKS.indexOf('5'); } }
  }
  if(isSF) return [8, topSF];
  if(byCount[4]) return [7, byCount[4][0], ...(byCount[1]||[])];
  if(byCount[3] && byCount[2]) return [6, byCount[3][0], byCount[2][0]];
  if(isFlush){
    const flushRanks = cards.filter(c=>suitCounts[c[1]]>=5).map(c=>RANKS.indexOf(c[0])).sort((a,b)=>b-a).slice(0,5);
    return [5, ...flushRanks];
  }
  if(isStraight) return [4, topStraight];
  if(byCount[3]) return [3, byCount[3][0], ...(byCount[1]||[]).slice(0,2)];
  if(byCount[2] && byCount[2].length>=2) return [2, byCount[2][0], byCount[2][1], ...(byCount[1]||[])];
  if(byCount[2]) return [1, byCount[2][0], ...(byCount[1]||[]).slice(0,3)];
  const high = ranks.map(r=>RANKS.indexOf(r)).sort((a,b)=>b-a).slice(0,5);
  return [0, ...high];
}
function cmpScore(a,b){ for(let i=0;i<Math.max(a.length,b.length);i++){ const av=a[i]||0, bv=b[i]||0; if(av!==bv) return av-bv; } return 0; }
function bestHandFrom7(cards7){ let best=null; const n=cards7.length;
  for(let i=0;i<n-4;i++) for(let j=i+1;j<n-3;j++) for(let k=j+1;k<n-2;k++) for(let l=k+1;l<n-1;l++) for(let m=l+1;m<n;m++){
    const hand=[cards7[i],cards7[j],cards7[k],cards7[l],cards7[m]]; const score=evaluate5(hand);
    if(!best || cmpScore(score,best.score)>0) best={score,hand};
  } return best;
}

/* ---- 游戏数据与初始状态 ---- */
let game = {
  depth: 1, roomsPerDepth: 6, currentRoom: -1, rooms: [],
  player: {hp: 30, maxHp:30, gold: 150, xp:0, lvl:1, dmgMult:1.0, wildcards:0},
  enemyPool: [],
  deck: [],
  community: [],
  wagers: 0,
  state: 'idle' // idle, inRoom, inCombat, resolved
};

/* ---- 敌人生成 ---- */
function genEnemy(depth){
  // enemy scales with depth
  const baseHp = 8 + depth*4 + Math.floor(Math.random()*6);
  const mul = 1 + depth*0.15 + (Math.random()*0.4-0.2);
  const name = ['落魄赌徒','愤怒的贵族','赌桌盗贼','食客','赏金猎人'][Math.floor(Math.random()*5)];
  const goldReward = 40 + depth*15 + Math.floor(Math.random()*30);
  const xp = 10 + depth*5;
  return {name: name, hp: baseHp, maxHp: baseHp, mul: Number(mul.toFixed(2)), goldReward, xp};
}

/* ---- 房间生成: 每层包含 多个 房间：战斗/商店/事件/休息 ---- */
function generateRooms(depth){
  const arr=[];
  for(let i=0;i<game.roomsPerDepth;i++){
    const r = Math.random();
    if(r<0.55) arr.push({type:'combat', enemy: genEnemy(depth), visited:false});
    else if(r<0.72) arr.push({type:'shop', items: genShop(depth), visited:false});
    else if(r<0.88) arr.push({type:'event', visited:false});
    else arr.push({type:'rest', visited:false});
  }
  return arr;
}

function genShop(depth){
  // list of items: buyable with gold
  return [
    {id:'hp+10', name:`+10 Max HP`, price:80+depth*10, apply:()=>{ game.player.maxHp+=10; game.player.hp+=10; }},
    {id:'dmg+0.1', name:`+0.1 Damage Mult`, price:100+depth*15, apply:()=>{ game.player.dmgMult = Number((game.player.dmgMult+0.1).toFixed(2)); }},
    {id:'wild', name:`野牌 x1`, price:150+depth*20, apply:()=>{ game.player.wildcards++; }},
  ].sort(()=>Math.random()-0.5);
}

/* ---- UI 简化函数 ---- */
function el(id){ return document.getElementById(id); }
function setText(id, t){ el(id).textContent = t; }
function log(s){ el('log').innerHTML = (new Date()).toLocaleTimeString() + ' — ' + s + '<br>' + el('log').innerHTML; }

/* ---- 渲染 ---- */
function renderAll(){
  setText('depth', game.depth);
  setText('gold', game.player.gold);
  setText('gold2', game.player.gold);
  setText('xp', game.player.xp);
  setText('hp', game.player.hp);
  setText('maxHp', game.player.maxHp);
  setText('playerHp', game.player.hp);
  setText('lvl', game.player.lvl);
  setText('dmgMult', game.player.dmgMult.toFixed(2));
  setText('enemyHp', game.rooms[game.currentRoom] && game.rooms[game.currentRoom].enemy ? Math.max(0, game.rooms[game.currentRoom].enemy.hp) : '—');
  setText('enemyName', game.rooms[game.currentRoom] && game.rooms[game.currentRoom].enemy ? game.rooms[game.currentRoom].enemy.name : '—');
  setText('stageLabel', game.state);
  setText('roomLabel', (game.currentRoom>=0? (game.currentRoom+1) : '—'));
  // rooms
  const roomsDiv = el('rooms'); roomsDiv.innerHTML='';
  game.rooms.forEach((r,i)=>{
    const d = document.createElement('div'); d.className='room'; d.innerHTML = `<div>#${i+1}</div><div class="small">${r.type}</div><div class="small">${r.visited? '已' : '未'}</div>`;
    if(i===game.currentRoom) d.style.outline='2px solid rgba(255,209,102,0.3)';
    roomsDiv.appendChild(d);
  });
  // enemy / player cards
  renderCards('playerCards', game.player.hand || []);
  renderCards('enemyCards', (game.rooms[game.currentRoom] && game.rooms[game.currentRoom].enemy) ? (game.rooms[game.currentRoom].enemy.hand || []) : []);
  // community
  const com = el('community'); com.innerHTML='';
  (game.community||[]).forEach(c=>{ const cc = document.createElement('div'); cc.className='card'; cc.textContent = cardText(c); com.appendChild(cc); });
  // shop
  const shopDiv = el('shop'); if(game.rooms[game.currentRoom] && game.rooms[game.currentRoom].type==='shop'){ shopDiv.innerHTML=''; game.rooms[game.currentRoom].items.forEach((it,idx)=>{ const b=document.createElement('div'); b.innerHTML=`<div style="display:flex;justify-content:space-between;align-items:center"><div>${it.name}</div><div>${it.price}g <button class="btn ghost" onclick="buyItem(${idx})">购买</button></div></div>`; shopDiv.appendChild(b); }) } else shopDiv.innerHTML = '在商店内可购买强化。';
}

/* Render card arrays, hiding enemy cards until showdown or if enemy.allRevealed flag set */
function renderCards(id, arr){
  const div = el(id); if(!div) return; div.innerHTML='';
  (arr||[]).forEach(c=>{ const cc=document.createElement('div'); cc.className='card'; cc.textContent = c? cardText(c) : ''; div.appendChild(cc); });
}

/* ---- 游戏流程控制 ---- */
function startRun(){
  game.depth = 1; game.player = {...game.player, hp:30, maxHp:30, gold:150, xp:0, lvl:1, dmgMult:1.0, wildcards:0}; // reset some
  game.rooms = generateRooms(game.depth); game.currentRoom = -1; game.state='idle'; game.community=[]; game.deck=[];
  log('开始新的游玩。探索房间，战斗、购买升级或休息。');
  renderAll();
}

function enterNextRoom(){
  if(game.state === 'inCombat') { log('当前战斗尚未结束'); return; }
  // find next unvisited room
  const idx = game.rooms.findIndex(r => !r.visited);
  if(idx===-1){
    // 层完成，进下一层
    game.depth++; game.rooms = generateRooms(game.depth); game.currentRoom = -1;
    log('本层完成，进入下一层：' + game.depth);
    renderAll();
    return;
  }
  game.currentRoom = idx; game.rooms[idx].visited = true;
  const room = game.rooms[idx];
  setText('roomLabel', idx+1);
  if(room.type === 'combat'){
    // prepare enemy: shuffle deck and give enemy two cards later
    game.state = 'inRoom';
    game.wagers = Number(document.getElementById('wager').value)||0;
    // ensure deck
    game.deck = createDeck();
    room.enemy.hand = [game.deck.pop(), game.deck.pop()];
    game.player.hand = [game.deck.pop(), game.deck.pop()];
    room.enemy.hp = room.enemy.maxHp;
    game.community = [];
    log(`进入战斗房间：${room.enemy.name}（生命 ${room.enemy.hp}） - 你下注 ${game.wagers}`);
    renderAll();
    el('enterBtn').disabled = false;
  } else if(room.type === 'shop'){ game.state='inShop'; log('进入商店'); renderAll(); }
  else if(room.type === 'event'){ game.state='inEvent'; doEvent(room); renderAll(); }
  else if(room.type === 'rest'){ game.state='rest'; game.player.hp = Math.min(game.player.maxHp, game.player.hp + Math.floor(game.player.maxHp*0.3)); log('在休息处恢复生命'); renderAll(); }
}

/* Event example */
function doEvent(room){
  const r = Math.random();
  if(r<0.4){ const gain = 30 + game.depth*5; game.player.gold += gain; log('你发现钱袋，获得 ' + gain + ' 金币'); }
  else if(r<0.8){ const dmg = 5 + game.depth*3; game.player.hp = Math.max(0, game.player.hp - dmg); log('你被陷阱击中，损失 ' + dmg + ' 生命'); if(game.player.hp<=0) doPlayerDeath(); }
  else { game.player.wildcards++; log('你找到一张野牌（可在战斗中作为任意牌使用）'); }
  room.visited = true;
}

/* 商店购买 */
function buyItem(idx){
  const room = game.rooms[game.currentRoom];
  if(!room || room.type!=='shop') return;
  const item = room.items[idx];
  if(!item) return;
  if(game.player.gold < item.price){ log('金币不足'); return; }
  game.player.gold -= item.price; item.apply();
  log('购买: ' + item.name);
  renderAll();
}

/* 发牌并比较（战斗核心） */
function dealCombat(){
  if(game.state !== 'inRoom' && game.state !== 'inCombat') { log('请先进入战斗房间'); return; }
  const room = game.rooms[game.currentRoom];
  if(!room || room.type !== 'combat') return;
  // Reveal community 5 cards (simulate dealing all at once for simplicity)
  while(game.community.length < 5) game.community.push(game.deck.pop());
  // If player has wildcards, allow them to auto-replace one card in their hand to best possible (simple usage)
  if(game.player.wildcards>0){
    // Simple: convert first wildcard to Ace of any suit to improve — (演示用途)
    // Real implementation应让玩家选择替换
    game.player.hand[0] = 'A' + ['s','h','d','c'][Math.floor(Math.random()*4)];
    game.player.wildcards--;
    log('使用了 1 张 野牌（自动转换为随机 A）');
  }
  // compute best hands
  const player7 = [...game.player.hand, ...game.community];
  const enemy7 = [...room.enemy.hand, ...game.community];
  const pBest = bestHandFrom7(player7);
  const eBest = bestHandFrom7(enemy7);
  // compute damage/gold based on compare
  const cmp = cmpScore(pBest.score, eBest.score);
  const wager = Number(document.getElementById('wager').value) || 0;
  // baseDamage = categoryDiff * 4 + kicker advantage sum
  // We'll compute a simple numeric value from score for damage scaling
  function scoreValue(sc){
    // convert score array to a single numeric magnitude
    let val = sc[0]*100000;
    for(let i=1;i<sc.length;i++) val += (sc[i]||0)*Math.pow(100, Math.max(0, 4-i));
    return val;
  }
  const pVal = scoreValue(pBest.score), eVal = scoreValue(eBest.score);
  const diff = Math.max(1, Math.floor((pVal - eVal)/50000)); // positive if player stronger
  const baseDam = Math.abs(diff);
  const finalDamToEnemy = Math.max(0, Math.floor(baseDam * game.player.dmgMult + wager*0.1));
  const finalDamToPlayer = Math.max(0, Math.floor(baseDam * room.enemy.mul + (wager>0 ? Math.floor(wager*0.05):0)));
  // Determine winner / lose
  log(`你牌型: ${handName(pBest.score[0])}，对手牌型: ${handName(eBest.score[0])}`);
  if(pVal > eVal){
    // player wins: damage enemy
    room.enemy.hp -= finalDamToEnemy;
    game.player.gold += Math.max(0, Math.floor(room.enemy.goldReward * (1 + wager*0.01)));
    game.player.xp += room.enemy.xp;
    log(`你赢了！对敌人造成 ${finalDamToEnemy} 伤害，获得 ${Math.max(0, Math.floor(room.enemy.goldReward * (1 + wager*0.01)))}g`);
  } else if(pVal < eVal){
    game.player.hp -= finalDamToPlayer;
    log(`你输了，受到 ${finalDamToPlayer} 伤害`);
    if(game.player.hp <= 0) doPlayerDeath();
  } else {
    log('平局，无人受伤');
  }
  // mark end of combat
  game.state = 'inCombat';
  renderAll();
  // check enemy death
  if(room.enemy.hp <= 0){
    log(`击败 ${room.enemy.name}，获得 ${room.enemy.goldReward}g 和 ${room.enemy.xp} 经验`);
    game.player.gold += room.enemy.goldReward;
    game.player.xp += room.enemy.xp;
    // reward scaling applied earlier as well
    // mark room cleared
    game.rooms[game.currentRoom].cleared = true;
    // allow proceed
  }
}

/* Shock simple death & level */
function doPlayerDeath(){
  log('你死亡了！游戏重置。');
  // For demo: reset run
  setTimeout(()=> startRun(), 1200);
}

/* simple hand name */
function handName(cat){
  return ['高牌','一对','两对','三条','顺子','同花','葫芦','铁支','同花顺'][cat] || '?';
}

/* ---- UI buttons and events ---- */
el('restart').addEventListener('click', ()=> startRun());
el('nextBtn').addEventListener('click', ()=> enterNextRoom());
el('enterBtn').addEventListener('click', ()=> enterNextRoom());
el('dealBtn').addEventListener('click', ()=> dealCombat());
el('foldBtn').addEventListener('click', ()=> { if(game.state==='inRoom'){ log('你弃牌了，房间失败'); game.rooms[game.currentRoom].cleared = false; game.state='idle'; renderAll(); } });

el('buyHp').addEventListener('click', ()=> {
  const cost = 100; if(game.player.gold<cost){ log('金币不足'); return; } game.player.gold-=cost; game.player.maxHp+=10; game.player.hp+=10; log('购买 +10 MaxHP'); renderAll();
});
el('buyDmg').addEventListener('click', ()=> {
  const cost=120; if(game.player.gold<cost){ log('金币不足'); return; } game.player.gold-=cost; game.player.dmgMult = Number((game.player.dmgMult + 0.1).toFixed(2)); log('购买 +0.1 伤害倍率'); renderAll();
});
el('buyWild').addEventListener('click', ()=> {
  const cost=200; if(game.player.gold<cost){ log('金币不足'); return; } game.player.gold-=cost; game.player.wildcards++; log('购买 野牌 x1'); renderAll();
});

/* ---- 初始化并开始首局 ---- */
startRun();
renderAll();
</script>
</body>
</html>