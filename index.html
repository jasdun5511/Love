<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>德州扑克 — 单页 完整版（玩家 vs AI）</title>
<style>
  :root{
    --bg:#062017; --table:#0c4b2a; --panel:#083b29; --accent:#ffd166;
    --card-bg:#ffffff; --card-color:#111;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;background:linear-gradient(180deg,#03120a,#04251a);color:#e9f6ef;min-height:100vh;display:flex;justify-content:center;align-items:flex-start;padding:24px}
  .wrap{width:100%;max-width:1100px}
  header{display:flex;gap:12px;align-items:center;margin-bottom:12px}
  h1{margin:0;font-size:20px}
  .controls{margin-left:auto;display:flex;gap:8px}
  button{background:var(--accent);border:none;padding:8px 12px;border-radius:8px;color:#07211a;font-weight:700;cursor:pointer}
  button.ghost{background:transparent;color:var(--accent);border:1px solid rgba(255,209,102,0.14)}
  .table{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border-radius:14px;padding:16px;display:grid;grid-template-columns:1fr 360px;gap:12px}
  .board{background:var(--table);border-radius:12px;padding:16px;min-height:420px;position:relative;overflow:hidden}
  .sidebar{background:var(--panel);padding:12px;border-radius:12px}
  .community{display:flex;gap:12px;justify-content:center;margin-top:20px}
  .card{width:72px;height:100px;border-radius:8px;background:var(--card-bg);color:var(--card-color);display:flex;align-items:center;justify-content:center;font-weight:800;box-shadow:0 6px 18px rgba(0,0,0,0.4);transform-origin:center;transition:transform .35s,opacity .35s}
  .card.back{background:linear-gradient(180deg,#093,#060);color:transparent}
  .seat-row{display:flex;gap:12px;flex-wrap:wrap;justify-content:space-between}
  .seat{width:32%;min-width:180px;background:rgba(0,0,0,0.15);padding:10px;border-radius:10px}
  .seat .name{font-weight:700}
  .cards{display:flex;gap:8px;margin-top:8px}
  .chips{display:flex;gap:6px;align-items:center;margin-top:8px}
  .chip{width:44px;height:26px;border-radius:14px;background:var(--accent);color:#07211a;display:inline-flex;align-items:center;justify-content:center;font-weight:800}
  .pot{position:absolute;left:50%;top:46%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.25);padding:10px 16px;border-radius:999px;font-weight:800}
  .log{height:120px;overflow:auto;margin-top:14px;background:rgba(0,0,0,0.25);padding:8px;border-radius:8px;font-size:13px}
  .actions{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}
  input[type=number]{width:96px;padding:8px;border-radius:8px;border:none}
  .small{font-size:13px;color:rgba(230,238,248,0.8)}
  .fadein{animation:fadein .4s ease both}
  @keyframes fadein{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:none}}
  @media(max-width:980px){.table{grid-template-columns:1fr}.seat{width:48%}}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>德州扑克 — 单页 完整版</h1>
    <div class="controls">
      <label class="small">小盲<input id="sb" type="number" value="10" style="width:64px;margin-left:6px"></label>
      <label class="small">大盲<input id="bb" type="number" value="20" style="width:64px;margin-left:6px"></label>
      <button id="newBtn">新局</button>
      <button id="autoBtn" class="ghost">AI 强度: 中</button>
    </div>
  </header>

  <div class="table">
    <div class="board">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div class="small">阶段 <span id="stage">等待</span></div>
          <div class="small">当前行动: <span id="current">—</span></div>
        </div>
        <div>
          <div class="small">桌面底池</div>
          <div style="font-weight:800;font-size:18px" id="potView">0</div>
        </div>
      </div>

      <div class="community" id="community"></div>

      <div style="margin-top:20px">
        <div class="seat-row">
          <div class="seat" id="aiSeat">
            <div class="name">AI</div>
            <div class="small">状态: <span id="aiState">准备</span></div>
            <div class="cards" id="aiCards"></div>
            <div class="chips">筹码: <div class="chip" id="aiChips">1000</div></div>
          </div>

          <div class="seat" id="playerSeat">
            <div class="name">你</div>
            <div class="small">状态: <span id="playerState">准备</span></div>
            <div class="cards" id="playerCards"></div>
            <div class="chips">筹码: <div class="chip" id="playerChips">1000</div></div>
          </div>
        </div>
      </div>

      <div class="pot" id="potBubble">底池: 0</div>

      <div class="log" id="log"></div>
    </div>

    <aside class="sidebar">
      <div>
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>行动区</strong>
          <div class="small">下注量 <input id="betInput" type="number" value="50"></div>
        </div>

        <div class="actions">
          <button id="checkBtn">Check</button>
          <button id="callBtn">Call</button>
          <button id="raiseBtn">Raise</button>
          <button id="foldBtn" style="background:#ef476f;color:white">Fold</button>
        </div>

        <div style="margin-top:12px">
          <div class="small">信息</div>
          <div id="info" class="small">点击 <strong>新局</strong> 开始</div>
        </div>

        <div style="margin-top:12px">
          <strong>AI 胜率估算</strong>
          <div class="small" id="aiEval">—</div>
        </div>

        <div style="margin-top:12px">
          <strong>说明</strong>
          <div class="small">此演示支持完整牌型评估与基于蒙特卡洛的 AI 胜率估算。多人在线需后端（可扩展）。</div>
        </div>
      </div>
    </aside>
  </div>
</div>

<script>
/*
  主要功能：
   - 7 张牌完整牌型判断（通过枚举 5 张组合取最大）
   - 下注轮：preflop/flop/turn/river + 简化盲注、check/call/raise/fold、all-in（简单处理）
   - AI 使用蒙特卡洛模拟估算胜率并基于阈值决策（可设强度）
   - 简单发牌/翻牌动画（CSS transform）
*/

const RANKS = ['2','3','4','5','6','7','8','9','T','J','Q','K','A'];
const SUITS = ['s','h','d','c'];

function createDeck(){
  const d = [];
  for(const r of RANKS) for(const s of SUITS) d.push(r+s);
  return shuffle(d);
}
function shuffle(a){
  for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; }
  return a;
}

function el(id){ return document.getElementById(id) }
function log(s){ el('log').innerHTML = (new Date()).toLocaleTimeString() + ' — ' + s + '<br>' + el('log').innerHTML; }

let state = {
  deck: [],
  players: [
    {id:'ai', name:'AI', chips:1000, hand:[], folded:false, allin:false},
    {id:'me', name:'You', chips:1000, hand:[], folded:false, allin:false}
  ],
  community: [],
  pot: 0,
  currentBet: 0,
  toAct: 0, // index in players
  stage: 'waiting', // waiting, preflop, flop, turn, river, showdown
  sb: 10, bb:20,
  minRaise: 20,
  aiStrength: 2, // 1=弱,2=中,3=强
};

// ------- UI helpers -------
function render(){
  // community
  const c = el('community'); c.innerHTML='';
  state.community.forEach((cd, i)=> {
    const div = document.createElement('div'); div.className='card fadein';
    div.style.transitionDelay = (i*80)+'ms'; div.innerHTML = cardText(cd); c.appendChild(div);
  });
  // players
  const ai = state.players[0], me = state.players[1];
  renderCards('aiCards', ai.hand, state.stage === 'showdown' || ai.allin ? false : true); // hide unless showdown or allin
  renderCards('playerCards', me.hand, false);
  el('playerChips').textContent = me.chips;
  el('aiChips').textContent = ai.chips;
  el('potView').textContent = state.pot;
  el('potBubble').textContent = '底池: ' + state.pot;
  el('stage').textContent = state.stage;
  el('current').textContent = state.players[state.toAct].name;
}

function renderCards(id, arr, hide){
  const wrap = el(id); wrap.innerHTML='';
  if(!arr) return;
  arr.forEach((c,i)=>{
    const div = document.createElement('div'); div.className='card';
    if(hide) { div.classList.add('back'); div.textContent=''; }
    else div.innerHTML = cardText(c);
    div.style.marginLeft = i? '6px' : '0';
    wrap.appendChild(div);
  });
}

function cardText(code){
  if(!code) return '';
  const rank = code[0], suit = code[1];
  const map = {s:'♠',h:'♥',d:'♦',c:'♣'};
  return rank + map[suit];
}

// ------- Hand evaluation (7 -> best 5) -------
/* Evaluate 5-card hand returning a comparable score array.
   Higher better. Score format: [category, tiebreaker...]
   categories: 8 straight flush,7 four,6 full house,5 flush,4 straight,3 trips,2 two pair,1 pair,0 high card
*/
function evaluate5(cards){ // cards: array of 5 codes like 'As'
  // map to ranks idx and suits
  const ranks = cards.map(c=>c[0]);
  const suits = cards.map(c=>c[1]);
  const counts = {};
  for(const r of ranks) counts[r] = (counts[r]||0)+1;
  const byCount = {};
  for(const [r,c] of Object.entries(counts)){ byCount[c] = byCount[c]||[]; byCount[c].push(RANKS.indexOf(r)); }
  for(const k in byCount) byCount[k].sort((a,b)=>b-a);
  // flush
  const suitCounts = {};
  for(const s of suits) suitCounts[s]=(suitCounts[s]||0)+1;
  const isFlush = Object.values(suitCounts).some(v=>v>=5);
  // straight
  const uniqRanks = Array.from(new Set(ranks.map(r=>RANKS.indexOf(r)))).sort((a,b)=>a-b);
  let isStraight = false, topStraight = -1;
  for(let i=0;i<uniqRanks.length;i++){
    let seq=1, last=uniqRanks[i];
    for(let j=i+1;j<uniqRanks.length;j++){
      if(uniqRanks[j]===last+1){seq++; last=uniqRanks[j];}
      else break;
    }
    if(seq>=5){ isStraight=true; topStraight=last; break; }
  }
  // wheel A-2-3-4-5
  if(!isStraight){
    const wheel = ['A','2','3','4','5'];
    if(wheel.every(r=>ranks.includes(r))){ isStraight=true; topStraight = RANKS.indexOf('5'); }
  }
  // straight flush (brute force by suit)
  let isSF=false, topSF=-1;
  for(const s of SUITS){
    const rc = cards.filter(c=>c[1]===s).map(c=>c[0]);
    const idxs = Array.from(new Set(rc.map(r=>RANKS.indexOf(r)))).sort((a,b)=>a-b);
    for(let i=0;i<idxs.length;i++){
      let seq=1, last=idxs[i];
      for(let j=i+1;j<idxs.length;j++){
        if(idxs[j]===last+1){seq++; last=idxs[j]} else break;
      }
      if(seq>=5){ isSF=true; topSF=last; break; }
    }
    if(!isSF){
      const wheel = ['A','2','3','4','5'];
      if(wheel.every(r=>rc.includes(r))){ isSF=true; topSF = RANKS.indexOf('5'); }
    }
  }

  if(isSF) return [8, topSF];
  if(byCount[4]) return [7, byCount[4][0], ...(byCount[1]||[])];
  if(byCount[3] && byCount[2]) return [6, byCount[3][0], byCount[2][0]];
  if(isFlush){
    // top flush ranks
    const flushRanks = cards.filter(c=>suitCounts[c[1]]>=5).map(c=>RANKS.indexOf(c[0])).sort((a,b)=>b-a).slice(0,5);
    return [5, ...flushRanks];
  }
  if(isStraight) return [4, topStraight];
  if(byCount[3]) return [3, byCount[3][0], ...(byCount[1]||[]).slice(0,2)];
  if(byCount[2] && byCount[2].length>=2) return [2, byCount[2][0], byCount[2][1], ...(byCount[1]||[])];
  if(byCount[2]) return [1, byCount[2][0], ...(byCount[1]||[]).slice(0,3)];
  // high card
  const high = ranks.map(r=>RANKS.indexOf(r)).sort((a,b)=>b-a).slice(0,5);
  return [0,...high];
}

function cmpScore(a,b){
  for(let i=0;i<Math.max(a.length,b.length);i++){
    const av=a[i]||0, bv=b[i]||0;
    if(av!==bv) return av-bv;
  }
  return 0;
}

function bestHandFrom7(cards7){
  // enumerate 21 combos choose 5
  let best = null;
  const n = cards7.length;
  for(let i=0;i<n-4;i++) for(let j=i+1;j<n-3;j++) for(let k=j+1;k<n-2;k++) for(let l=k+1;l<n-1;l++) for(let m=l+1;m<n;m++){
    const hand = [cards7[i],cards7[j],cards7[k],cards7[l],cards7[m]];
    const score = evaluate5(hand);
    if(!best || cmpScore(score, best.score) > 0) best = {score, hand};
  }
  return best;
}

// ------- AI: Monte Carlo estimate -------
// Simulate N random completions to estimate equity vs unknown opponent hands (assumes single opponent)
function estimateEquity(myHand, board, iterations=800){
  // build known cards set
  const known = new Set([...myHand, ...board]);
  const deck = [];
  for(const r of RANKS) for(const s of SUITS) {
    const code = r+s; if(!known.has(code)) deck.push(code);
  }
  let wins=0, ties=0;
  const need = 5 - board.length;
  for(let it=0; it<iterations; it++){
    shuffle(deck);
    // sample opponent two cards from deck (top)
    const opp = [deck[0], deck[1]];
    // sample rest of board
    const rest = deck.slice(2, 2 + need);
    const finalBoard = board.concat(rest);
    const myBest = bestHandFrom7(myHand.concat(finalBoard)).score;
    const oppBest = bestHandFrom7(opp.concat(finalBoard)).score;
    const cmp = cmpScore(myBest, oppBest);
    if(cmp>0) wins++;
    else if(cmp===0) ties++;
    // rotate deck a bit for randomness
    if(deck.length>5) deck.push(deck.shift());
  }
  return (wins + ties*0.5) / iterations;
}

// ------- Game flow -------

function resetTable(){
  state.deck = createDeck();
  state.community = [];
  state.pot = 0;
  state.currentBet = 0;
  state.players.forEach(p=>{ p.hand = []; p.folded=false; p.allin=false; });
  // rotate dealer - here we keep AI as dealer for simplicity: AI small blind, player big blind? We'll set SB/BB manual
  state.stage = 'waiting';
  render();
  el('info').textContent = '准备就绪，点击 新局 开始。';
}

function startHand(){
  state.deck = createDeck();
  state.community = [];
  state.pot = 0;
  state.currentBet = 0;
  state.players.forEach(p=>{ p.hand = []; p.folded=false; p.allin=false; });
  // deal
  state.players[0].hand = [state.deck.pop(), state.deck.pop()]; // AI
  state.players[1].hand = [state.deck.pop(), state.deck.pop()]; // me
  // blinds
  const sb = Number(el('sb').value)||10, bb = Number(el('bb').value)||20;
  state.sb = sb; state.bb = bb;
  // deduct blinds (AI sb, me bb)
  let ai = state.players[0], me = state.players[1];
  const sbAmt = Math.min(sb, ai.chips); ai.chips -= sbAmt; state.pot += sbAmt;
  const bbAmt = Math.min(bb, me.chips); me.chips -= bbAmt; state.pot += bbAmt;
  state.currentBet = bbAmt;
  state.toAct = 0; // AI acts first preflop (left of big blind)
  state.stage = 'preflop';
  log(`新局：AI 支付小盲 ${sbAmt}, 你支付大盲 ${bbAmt}`);
  render();
  el('info').textContent = '发牌完成，进行下注。';
  // AI may act immediately
  setTimeout(()=> { if(state.toAct===0) aiAct(); }, 600);
}

// player actions
function playerCheck(){
  if(state.players[state.toAct].id !== 'me') { log('不是你的回合'); return; }
  log('你 选择 Check');
  nextToAct();
}
function playerCall(){
  if(state.players[state.toAct].id !== 'me') { log('不是你的回合'); return; }
  const toCall = state.currentBet;
  const me = state.players[1];
  const pay = Math.min(toCall, me.chips);
  me.chips -= pay; state.pot += pay;
  log('你 跟注 ' + pay);
  nextToAct();
}
function playerRaise(){
  if(state.players[state.toAct].id !== 'me') { log('不是你的回合'); return; }
  const amt = Number(el('betInput').value) || state.minRaise;
  const me = state.players[1];
  if(amt <= state.currentBet) { el('info').textContent='加注必须大于当前注'; return; }
  const pay = Math.min(amt, me.chips);
  me.chips -= pay; state.pot += pay; state.currentBet = pay;
  log('你 加注 ' + pay);
  nextToAct();
}
function playerFold(){
  if(state.players[state.toAct].id !== 'me') { log('不是你的回合'); return; }
  state.players[1].folded = true;
  log('你 弃牌');
  endHand();
}

// advance turn or stage
function nextToAct(){
  state.toAct = (state.toAct + 1) % state.players.length;
  render();
  // check if everyone acted -> move stage
  // For simplicity: after both acted once per stage, we move progress. We'll track a simple counter:
  if(state.toAct === 0){
    // both acted -> advance stage
    setTimeout(()=> advanceStage(), 400);
  } else {
    // AI turn
    setTimeout(()=> aiAct(), 500);
  }
}

// AI decision-making: use equity to decide check/call/raise/fold
async function aiAct(){
  const ai = state.players[0], me = state.players[1];
  if(ai.folded || ai.allin) { nextToAct(); return; }
  el('info').textContent = 'AI 思考中...';
  // estimate equity for AI
  const equity = estimateEquity(ai.hand, state.community, 600);
  el('aiEval').textContent = 'AI 胜率估算: ' + Math.round(equity*100) + '%';
  // decision thresholds depend on strength
  let raiseThresh = 0.60, callThresh = 0.40;
  if(state.aiStrength===1){ raiseThresh = 0.68; callThresh = 0.35; }
  else if(state.aiStrength===3){ raiseThresh = 0.52; callThresh = 0.28; }
  // If preflop, be slightly more conservative
  if(state.stage==='preflop'){ raiseThresh += 0.08; callThresh += 0.05; }

  // AI logic:
  const rnd = Math.random();
  const toCall = state.currentBet;
  if(equity > raiseThresh && ai.chips>0 && rnd<0.9){
    // raise
    const raiseAmt = Math.min(ai.chips, Math.max(state.minRaise, Math.round(state.currentBet * (1 + equity))));
    const pay = Math.min(raiseAmt, ai.chips);
    ai.chips -= pay; state.pot += pay; state.currentBet = pay;
    log(`AI 加注 ${pay}（估算胜率 ${Math.round(equity*100)}%）`);
  } else if(equity > callThresh || rnd < 0.12){
    // call or check
    const pay = Math.min(toCall, ai.chips);
    ai.chips -= pay; state.pot += pay;
    log(`AI 跟注 ${pay}（估算胜率 ${Math.round(equity*100)}%）`);
  } else {
    // fold
    ai.folded = true;
    log(`AI 弃牌（估算胜率 ${Math.round(equity*100)}%）`);
    endHand();
    return;
  }
  // continue
  nextToAct();
}

function advanceStage(){
  if(state.stage==='preflop'){ // deal flop
    state.community.push(state.deck.pop(), state.deck.pop(), state.deck.pop());
    state.stage='flop';
    state.currentBet = 0;
    log('翻牌: ' + state.community.map(cardText).join(' '));
    state.toAct = 0; render(); setTimeout(()=> aiAct(), 400);
  } else if(state.stage==='flop'){
    state.community.push(state.deck.pop()); state.stage='turn';
    state.currentBet = 0;
    log('转牌: ' + cardText(state.community[state.community.length-1]));
    state.toAct = 0; render(); setTimeout(()=> aiAct(), 400);
  } else if(state.stage==='turn'){
    state.community.push(state.deck.pop()); state.stage='river';
    state.currentBet = 0;
    log('河牌: ' + cardText(state.community[state.community.length-1]));
    state.toAct = 0; render(); setTimeout(()=> aiAct(), 400);
  } else if(state.stage==='river'){
    state.stage='showdown';
    log('到摊牌阶段');
    showdown();
  }
}

// showdown: evaluate remaining players
function showdown(){
  const active = state.players.filter(p=>!p.folded);
  if(active.length===1){
    // the other wins
    const winner = active[0];
    winner.chips += state.pot;
    log(`${winner.name} 赢得底池 ${state.pot}`);
    state.pot = 0;
    render();
    return;
  }
  // evaluate both
  const p0 = state.players[0], p1 = state.players[1];
  const best0 = bestHandFrom7(p0.hand.concat(state.community)).score;
  const best1 = bestHandFrom7(p1.hand.concat(state.community)).score;
  const cmp = cmpScore(best0, best1);
  // reveal all cards (force show)
  renderCards('aiCards', p0.hand, false);
  if(cmp>0){ p0.chips += state.pot; log(`AI 获胜，底池 ${state.pot}`); }
  else if(cmp<0){ p1.chips += state.pot; log(`你 获胜，底池 ${state.pot}`); }
  else { p0.chips += Math.floor(state.pot/2); p1.chips += Math.ceil(state.pot/2); log('平局，底池均分'); }
  state.pot=0; render();
}

// end hand after fold or showdown
function endHand(){
  state.stage='waiting'; render();
  el('info').textContent = '本局结束，点击 新局 开始下一局。';
}

// ------- UI events -------
el('newBtn').addEventListener('click', ()=> {
  // reset if first; else start new hand
  if(state.stage !== 'waiting') resetTable();
  startHand();
});
el('checkBtn').addEventListener('click', playerCheck);
el('callBtn').addEventListener('click', playerCall);
el('raiseBtn').addEventListener('click', playerRaise);
el('foldBtn').addEventListener('click', playerFold);
el('autoBtn').addEventListener('click', ()=>{
  state.aiStrength = state.aiStrength % 3 + 1;
  const labels = {1:'弱',2:'中',3:'强'};
  el('autoBtn').textContent = 'AI 强度: ' + labels[state.aiStrength];
});

// init
resetTable();
render();

/* Notes:
 - 本页面实现了较完整的 1v1 游戏体验，AI 使用蒙特卡洛估算（iteration 控制在 600 次，运行速度受浏览器影响）。
 - 边池与多玩家 all-in 的复杂情况未做完全实现（可进一步扩展）。
 - 若希望多人在线，请告诉我你要用的后端（Node.js + socket.io），我可以把服务器 + 客户端版本一起生成并给出部署步骤。
*/
</script>
</body>
</html>